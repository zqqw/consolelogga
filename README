Building consolelogga

Build requirements
glibc - other C libraries have not been tested.
gettext, with it's dev package if separate. (Optional)
scons.
gcc or clang / llvm - both tested, other compilers are supported by scons.
clang / llvm resulted in a ~20% smaller binary, stripped or unstripped.
(gcc (GCC) 6.3.0 vs clang version 4.0.1 i686-pc-linux-gnu posix)

Run time requirements
Init systems that write to /dev/console should be compatible, you will need to 
start consolelogga in the boot process. It won't work with systemd.

Run "./configure --help" or "python configure --help"
(configure is a python 2 & 3 script) in the source package directory:

$ ./configure --help
usage: configure [-h] [--prefix PREFIX] [--logrotatedir LOGROTATEDIR]
                 [--mandir MANDIR] [--compiler COMPILER] [--no_gettext]
                 [--no_strip]

optional arguments:
  -h, --help            show this help message and exit
  --prefix PREFIX       Installation prefix (default: /usr/local)
  --logrotatedir LOGROTATEDIR
                        logrotate script installation prefix (default:
                        /etc/logrotate.d)
  --mandir MANDIR       man file installation prefix (default:
                        /usr/share/man/man8)
  --compiler COMPILER   Manually set cc compiler (default: DEFAULT)
  --no_gettext          Compile without gettext (default: False)
  --no_strip            Do not strip the consolelogga binary (default: False)

Then run configure with appropriate options, or none if using default values.

To build without gettext translation support, specify --no-gettext which means 
gettext will no longer be needed as a build dependency. Any text from
consolelogga will then be in English. (Apart from consolelogga --help it's
only error messages you probably won't ever see.) 
gettext only affects messages and help text generated by consolelogga itself,
the content that it logs is what is shown on the console. Console messages are
created by many boot time processes which are responsible for providing their
own translations.

The build system used is SCons. Commands need to be run in the top level
directory where the SConstruct file is located.

"$ scons --help" provides a full list of options.
"$ scons" will build but not install anything.
"$ scons -c" will delete the built files.
"# scons --install" will build (if not previously built) and install files.
"# scons --uninstall" will delete installed files plus built files.

When installing, the files are put in the directories specified by configure.
It should only take seconds to run $ ./configure and # scons --install.


Using consolelogga
It's inspired by bootlogd from sysvinit but is a completely new blank page
implementation with different internal operation and extra features.
This allows a runit friendly BSD type licence, as Runit lacked a bootlogger.
It can log not only boot messages but also shutdown messages.
Start it as early as possible in the boot sequence, /dev must be populated.
It could be shutdown after boot and restarted just before shutdown. But it
will sleep on a blocking read indefinitely without console input, so all it
should use is a tiny bit of RAM and just starting it once is fine.
It should be automatically terminated by the init system when that sends a
sigterm to all remaining backround processes shortly before final shutdown.
This allows consolelogga to do any clean up and exit neatly by itself (before
the init sends a subsequent sigkill) but still log as much as practical.
Logs are written to /var/log/consolelogga.log but only if it already exists,
the messages are cached in RAM with a linked list until the log is available.
Everything written to /dev/console is intercepted then forwarded to the log
and the terminal(s) acting as the display console. The time each line is
received, not the time it's written to the log, can also be recorded.

$ consolelogga --help
Usage: consolelogga [OPTION...]
consolelogga : logs messages from the console at boot or shutdown
Default values, # consolelogga (with no options) :
Fork to background, no pidfile, console(s) found in /proc/consoles,
log to /var/log/consolelogga.log (if it exists)
Examples of use:
# consolelogga -xp  :  foreground with default pidfile
# consolelogga --pidpath=/new/path  :  custom pidfile location
# consolelogga -o /new/path  :  custom logfile location
# consolelogga -c"/dev/tty1 /dev/tty2"  :  write to tty1 & 2

  -c, --console=consolearg   Write to custom console(s)
  -e, --exact                Log messages without a timestamp
  -o, --output=/path/to/log  Define log file location
  -p, --pidfile              Write a pidfile to default location
  -P, --pidpath=/path/to/pid Define pidfile location
  -x, --nofork               Run as a foreground process, don't fork
  -?, --help                 Give this help list
      --usage                Give a short usage message
  -V, --version              Print program version

Starting consolelogga at boot - completing the installation.
Create /var/log/consolelogga.log (or the -o --output file.)

Start consolelogga as early as possible using the init implementation in use.
Your language may not be set this early, this can be resolved like this:
LANG=fr_FR.utf8 /usr/local/bin/consolelogga
Check available installed languages with 'locale -a'. The default is en_US.
This affects the log date format, consolelogga --help and error messages.

Void runit, copy ./src/scripts/01-consolelogga.sh to /etc/runit/core-services/
and add any extra consolelogga arguments if desired.
It isn't started as a runit service so it can log earlier and later, it is run
as an unmonitored unix daemon fully in the background.
But consolelogga can run as a foreground process so it could be a service.
It can write a pidfile for compatibility with sysvinit and related inits.

Uplos sysvinit (unlike Debian style sysvinit), edit /etc/rc.d/rc.sysinit:
mount -n -t devpts -o mode=620 none /dev/pts >/dev/null 2>&1
[ -n "$SELINUX_STATE" ] && restorecon /dev/pts >/dev/null 2>&1

# This seems to be the earliest it will start, consolelogga uses /dev/pts
if [ -x /usr/local/bin/consolelogga ] && [ -c /dev/console ]; then
	LANG=de_DE.utf8 /usr/local/bin/consolelogga -e
fi

The -e option improved the display slightly. Modify to suit.
You need to declare it a conf file to avoid updates overwriting that.
bootlogd from sysvinit conflicts with consolelogga, don't run both together.
It's run here as an unmonitored unix daemon fully in the background.

Arch OpenRC / Artix, copy src/scripts/openrc/consolelogga to
/usr/local/etc/init.d and add any extra consolelogga arguments if desired.
Add it to the sysinit runlevel:
# rc-update add consolelogga sysinit
It will autostart on boot and can be managed like this:
# rc-service consolelogga start
# rc-service consolelogga status
# rc-service consolelogga stop
And deactivated like this:
# rc-update delete consolelogga sysinit
This init script creates an unsupervised background daemon service.
You can enable rc_logger in /etc/openrc.conf to log boot messages as well.
That won't conflict with consolelogga. The -e option is near essential.

Viewing logs.
The logs can be viewed with any text viewer / editor. But they may contain
terminal control characters. To intepret these as when booting, use 'less -r'
'cat' or 'more'. See what's best, 'more' could miss an OpenRC line.
There are also apps available to remove control characters from a file.
The -e --exact option recreates the boot display more closely.
consolelogga logs everything written to /dev/console in it's entirety.

Bugs, patches:
Report bugs via : www.cxperimental.weebly.com
or at : https://github.com/zqqw/consolelogga

Peripheral information (not required reading).
Although consolelogga is supposed to determine the console or consoles in use,
on my system I have only 1 console. This is shown in /proc/consoles as tty0.
The output is displayed on tty1, so consolelogga reads messages sent to
/dev/console or /dev/tty0, logs them, then writes them on /dev/tty1.
Only 1 of each type of console can be used simultaneously, for example
console=tty0 console=lp0 console=ttyS0 is OK while
console=ttyS0 console=ttyS1 isn't.
But console=tty2 alone is OK. That is regarding the console= kernel command
line option, not the --console consolelogga option.
Because tty0 = tty1 for consolelogga's purposes, what does lp0 or ttyS0 mean?
Currently consolelogga would forward boot messages to lp0 and ttyS0.
This could be right, it could be wrong... this is partly why the -c --console
option exists! Suggestions for improvements if there are issues are welcome.
The tty's 1 - 7 can be viewed pressing CTRL ALT (F1 to F7) in most distros.
Usually 7 is the graphical X display, 1 has the boot messages and would be the
location for the terminal prompt if you were using startx at boot.
These displays are provided by agetty, setting --noclear as an option to the
agetty(s) displaying console output might be helpful. (Also with mingetty.)
Otherwise agetty deletes boot messages and shows only a login prompt even if
you have switched the console or written output to them using consolelogga.
consolelogga has no restriction on using multiple terminals of the same type,
write the output on as many tty's of any type as you want with -c --console.
Writing to tty7 (usually the graphical desktop session) may not be useful.
The interface to intercept messages from the console is provided by a kernel
ioctl, so the behaviour of that is fixed.
It is possible you may rarely encounter boot error messages that are not
logged. This could be because they have been written directly to the tty.
You can confirm this by not using consolelogga and using say console=tty2 on
the kernel command line. The message should still appear on the original tty
at boot without the other messages that were written to /dev/console and have
been redirected to tty2.
Advanced configuration tips:
Running configure again with new arguments after scons --install and before
scons --uninstall may leave some files in the old locations. Run configure
again with the original args to fix this.
An install prefix with no leading / installs in the top level source package
directory, useful for testing, or to avoid installing particular files.
The --no_gettext configure option means mo files are not built or installed.
The --prefix option specifies among other things the location of the gettext
.mo files. This value is cached and compiled into the consolelogga binary. So
the translations won't work if the .mo files are moved elsewhere later.
(In normal circumstances this allows consolelogga to find the translations
wherever it and they are installed.) If you needed to manually alter this,
modify consolelogga.c so it ignores the configure settings (USRPREFIX) here :
Original :  bindtextdomain ("consolelogga", USRPREFIX "/share/locale");
Modified :  bindtextdomain ("consolelogga", "/your/locale/location");


Translators
Contributing a new po file if you are fluent in an unsupported language.
Some sentences include an English code word noun like time or localtime which
isn't translated. See the existing translations for examples.
Adding support for a new language:
Edit src/po/LINGUAS and add the new language code
Run: scons po-update
Install "poedit".
poedit ??.po
Create and save the translation, you need to set UTF8 in poedit settings.
They're all created as ASCII by SCONS, future versions might fix this.
Almost all languges should be UTF8. In the poedit onscreen GUI, go to :
Catalogue (on the top bar)  - Properties - Charset : UTF-8 (recommended)
Add a line to SConstruct to rename and install the mo file.
(Copy an existing line and change the xx language code in the 2 places.)
Create the translation, verify and save the po file.
Build and install to test the result while using the appropriate locale.

I used online translators, suggestions for improvement are welcome.
Some lines in the consolelogga --help output are from glibc argp, not
consolelogga, they won't appear in the text to be translated in the po files.
The original definitive language is English.
